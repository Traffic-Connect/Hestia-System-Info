#!/bin/bash
#
# Кастомная команда Hestia: v-system-info
# Возвращает информацию о системе включая модель CPU, использование диска, RAM, статус бекапа и папки в /root
#
# Использование: ./v-system-info [--json|--text]
#

# Цвета для вывода
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # Без цвета

# Загружаем общую библиотеку если доступна
LIB_DIR="$(cd "$(dirname "$0")" && pwd)/lib"
[ -f "$LIB_DIR/system_info.sh" ] || LIB_DIR="/usr/local/hestia/lib/hestia-system-info"
[ -f "$LIB_DIR/system_info.sh" ] && . "$LIB_DIR/system_info.sh"

# Формат вывода по умолчанию
OUTPUT_FORMAT="text"

# Парсим аргументы командной строки
while [[ $# -gt 0 ]]; do
    case $1 in
        --json)
            OUTPUT_FORMAT="json"
            shift
            ;;
        --text)
            OUTPUT_FORMAT="text"
            shift
            ;;
        -h|--help)
            echo "Использование: $0 [--json|--text]"
            echo "  --json    Вывод в формате JSON"
            echo "  --text    Вывод в читаемом текстовом формате (по умолчанию)"
            echo "  -h, --help Показать эту справку"
            exit 0
            ;;
        *)
            echo "Неизвестная опция: $1"
            echo "Используйте -h или --help для получения справки"
            exit 1
            ;;
    esac
done

# Функция для получения модели CPU (запасной вариант если библиотека не загружена)
if ! declare -F get_cpu_model >/dev/null; then
get_cpu_model() {
    if [ -f /proc/cpuinfo ]; then
        grep "model name" /proc/cpuinfo | head -1 | cut -d: -f2 | xargs
    else
        lscpu | grep "Model name" | cut -d: -f2 | xargs 2>/dev/null || echo ""
    fi
}
fi

# Функция для вывода в текстовом формате
output_text() {
    echo -e "${BLUE}╔══════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${BLUE}║                    🖥️  ИНФОРМАЦИЯ О СИСТЕМЕ                    ║${NC}"
    echo -e "${BLUE}╚══════════════════════════════════════════════════════════════╝${NC}"
    echo
    
    # Модель процессора
    echo -e "${YELLOW}🔧 Модель процессора:${NC}"
    local cpu_model=$(get_cpu_model)
    echo -e "   ${GREEN}►${NC} $cpu_model"
    echo
    
    # Использование диска
    echo -e "${YELLOW}💾 Использование диска:${NC}"
    local disk_usage=$(get_disk_usage)
    local disk_info=$(get_disk_info)
    local total=$(echo "$disk_info" | jq -r '.total' 2>/dev/null || echo "Н/Д")
    local used=$(echo "$disk_info" | jq -r '.used' 2>/dev/null || echo "Н/Д")
    local available=$(echo "$disk_info" | jq -r '.available' 2>/dev/null || echo "Н/Д")
    
    # Прогресс-бар для использования диска
    local bar_length=20
    local filled=$(awk "BEGIN {printf \"%.0f\", $disk_usage * $bar_length / 100}" 2>/dev/null || echo "0")
    local empty=$((bar_length - filled))
    
    local progress_bar=""
    for ((i=0; i<filled; i++)); do
        progress_bar="${progress_bar}█"
    done
    for ((i=0; i<empty; i++)); do
        progress_bar="${progress_bar}░"
    done
    
    # Цвет в зависимости от использования
    local usage_color=$GREEN
    if [ "$(awk "BEGIN {print ($disk_usage > 80) ? 1 : 0}")" -eq 1 ]; then
        usage_color=$RED
    elif [ "$(awk "BEGIN {print ($disk_usage > 60) ? 1 : 0}")" -eq 1 ]; then
        usage_color=$YELLOW
    fi
    
    echo -e "   ${GREEN}►${NC} Использование: ${usage_color}${disk_usage}%${NC} [${progress_bar}]"
    echo -e "   ${GREEN}►${NC} Всего: ${BLUE}$total${NC}"
    echo -e "   ${GREEN}►${NC} Использовано: ${YELLOW}$used${NC}"
    echo -e "   ${GREEN}►${NC} Доступно: ${GREEN}$available${NC}"
    echo
    
    # Информация о RAM
    echo -e "${YELLOW}🧠 Информация о RAM:${NC}"
    local ram_info=$(get_ram_info)
    local ram_total=$(echo "$ram_info" | jq -r '.total' 2>/dev/null || echo "Н/Д")
    local ram_used=$(echo "$ram_info" | jq -r '.used' 2>/dev/null || echo "Н/Д")
    local ram_free=$(echo "$ram_info" | jq -r '.free' 2>/dev/null || echo "Н/Д")
    local ram_usage_percent=$(echo "$ram_info" | jq -r '.usage_percent' 2>/dev/null || echo "Н/Д")
    
    # Прогресс-бар для использования RAM
    local ram_bar_length=20
    local ram_filled=$(awk "BEGIN {printf \"%.0f\", $ram_usage_percent * $ram_bar_length / 100}" 2>/dev/null || echo "0")
    local ram_empty=$((ram_bar_length - ram_filled))
    
    local ram_progress_bar=""
    for ((i=0; i<ram_filled; i++)); do
        ram_progress_bar="${ram_progress_bar}█"
    done
    for ((i=0; i<ram_empty; i++)); do
        ram_progress_bar="${ram_progress_bar}░"
    done
    
    # Цвет в зависимости от использования RAM
    local ram_usage_color=$GREEN
    if [ "$(awk "BEGIN {print ($ram_usage_percent > 80) ? 1 : 0}")" -eq 1 ]; then
        ram_usage_color=$RED
    elif [ "$(awk "BEGIN {print ($ram_usage_percent > 60) ? 1 : 0}")" -eq 1 ]; then
        ram_usage_color=$YELLOW
    fi
    
    echo -e "   ${GREEN}►${NC} Использование: ${ram_usage_color}${ram_usage_percent}%${NC} [${ram_progress_bar}]"
    echo -e "   ${GREEN}►${NC} Всего: ${BLUE}$ram_total${NC}"
    echo -e "   ${GREEN}►${NC} Использовано: ${YELLOW}$ram_used${NC}"
    echo -e "   ${GREEN}►${NC} Свободно: ${GREEN}$ram_free${NC}"
    echo
    
    # Статус удаленного бекапа
    echo -e "${YELLOW}💾 Статус удаленного бекапа:${NC}"
    local backup_info=$(check_backup_status)
    local backup_enabled=$(echo "$backup_info" | jq -r '.enabled' 2>/dev/null || echo "false")
    local backup_status=$(echo "$backup_info" | jq -r '.status' 2>/dev/null || echo "неизвестно")
    
    if [ "$backup_enabled" = true ]; then
        echo -e "   ${GREEN}►${NC} Статус: ${GREEN}✅ $backup_status${NC}"
    else
        echo -e "   ${GREEN}►${NC} Статус: ${RED}❌ $backup_status${NC}"
    fi
    echo
    
    # Папки в /root
    echo -e "${YELLOW}📁 Папки в /root:${NC}"
    local folders_info=$(check_root_folders)
    
    echo "$folders_info" | jq -r 'to_entries[] | "   ► \(.key): \(if .value.exists then "✅ СУЩЕСТВУЕТ" else "❌ НЕ НАЙДЕНА" end)"' 2>/dev/null || {
        # Запасной вариант если jq недоступен
        for folder in "link-manager" "google-auth" "tc-api-site-details"; do
            if [ -d "/root/$folder" ]; then
                echo -e "   ${GREEN}►${NC} $folder: ${GREEN}✅ СУЩЕСТВУЕТ${NC}"
            else
                echo -e "   ${GREEN}►${NC} $folder: ${RED}❌ НЕ НАЙДЕНА${NC}"
            fi
        done
    }
    echo
    
    echo -e "${BLUE}╔══════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${BLUE}║                      📊 КОНЕЦ ОТЧЕТА                          ║${NC}"
    echo -e "${BLUE}╚══════════════════════════════════════════════════════════════╝${NC}"
}

# Функция для вывода в формате JSON
output_json() {
    local cpu_model=$(get_cpu_model)
    local disk_info=$(get_disk_info)
    local ram_info=$(get_ram_info)
    local backup_info=$(check_backup_status)
    local folders_info=$(check_root_folders)
    
    cat << EOF
{
  "cpu": {
    "model": "$cpu_model"
  },
  "disk": $disk_info,
  "ram": $ram_info,
  "remote_backup": $backup_info,
  "root_folders": $folders_info,
  "timestamp": "$(date '+%Y-%m-%d %H:%M:%S')",
  "server_timezone": "$(date '+%Z')"
}
EOF
}

# Основное выполнение
if [ "$OUTPUT_FORMAT" = "json" ]; then
    output_json
else
    output_text
fi
